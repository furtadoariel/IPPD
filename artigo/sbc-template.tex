\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage{graphicx,url}
\usepackage{amsmath}
\usepackage[brazil]{babel}   
\usepackage[latin1]{inputenc} 
\usepackage[portuguese, ruled, linesnumbered]{algorithm}

\usepackage{algorithmic}
     
\sloppy

\title{Ánalise de Aplicação de Programação Paralela Através de Estudos de Casos em Implementações em Problemas de Fractais}

\author{Ariel F. Azevedo\inst{1}, Rodrigo Acosta. *\inst{2}, Rodrigo Duarte \inst{1}}


\address{\textit{Laboratory of Ubiquitous and Parallel Systems} (LUPS) - \\ Universidade Federal de Pelotas (UFPel)
\nextinstitute
  Centro de Desenvolvimento Tecnológico - \\Faculdade de Ciência da Computação
  Universidade Federal de Pelotas (UFPel)
  \email{\{afazevedo,rmduarte, rdbacosta\}@inf.ufpel.edu.br
  }
}
\graphicspath{{figuras/}}
\begin{document} 

\maketitle


     
\begin{resumo} 
  Este artigo tem como objetivo apresentar uma solução para o problema de fractal (\textit{fractus} do latim, fração, quebrado) de forma paralela nas linguagens C++11 e OpenMP, 
  bem como uma abordagem sequencial para mostrar a diferença e importância de casos paralelisados.
  
  Este artigo será composto de uma sessão de introdução para apresentar o problema em si, logo após serão apresentadas ideias e soluções, 
  e por fim resultados obtidos ao longo do trabalho serão debatidos.
  
\end{resumo}


\section{Introdução}\label{sec:Intro}
  O uso de ambientes de programação paralela e distribuída tem sido recorrente para a execução de aplicações que exijam
  uma significativa capacidade de processamento de dados .\cite{Dongarra}.
  Dentre os principais motivos para utilização de programação paralela, pode-se citar a importância de reduzir o tempo necessários para as aplicações  
  solucionarem determinados problemas e, também, a necessidade de resolver problemas mais complexos de maior dimensão.\cite{Andrews}.
  Inicialmente, motivada pela resolução de problemas com grande relevância científica e econômica, denominados Grand Challenge Problems(GCPs) .\cite{Stout}
  iniciou-se a utilização de técnicas de processamento paralelo e distribuído.Atualmente, diversas aplicações exigem ou requerem um alto poder  
  de computação,para desta forma,efetuar o processamento de grandes quantidades de informações. O presente artigo busca demonstrar a aplicação de um problema sendo resolvido com
  o uso de programação paralela. Apesar de ser apenas uma avaliação para um problema que, de certa forma, demanda menor quantidade de processamento que os problemas complexos que temos
  atualmente, e que fazem uso de programação paralela, como por exemplo, análise de fenômenos climáticos (movimento das placas tectônicas), físicos (órbita dos planetas), 
  químicos (reações  nucleares), dentre outros tantos.
  Este artigo tem como objetivo então tratar sobre a implementação de fractais utilizando as ferramentas C++11 e OpenMP, e está dividido nas seguintes sessões:
  \ref{sec:Intro} Introdução,
  \ref{sec:Problem} Problema, onde será abordado um pouco sobre que é Fractal e suas características,
  \ref{sec:Conc} Conceitos, onde será falado sobre os principais conceitos abordados pelo artigo, para melhor entendimento da parte do leitor, 
  \ref{sec:Methodology} Metodologia, onde será descrito a forma como o problema foi abordado e as soluções tentadas,
  \ref{sec:Results} Resultados onde serão apresentados alguns dos resultados obtidos nos testes realizados e por fim, mas não menos importante 
  \ref{sec:Conclusion} Conclusão, onde será então discutido o desfecho do artigo e conclusão do grupo sobre o trabalho e resultados obtidos.

\section{Problema}\label{sec:Problem}
  A teoria fractal tem sua origem na descoberta do matemático alemão Karl Weierstrass que
encontrou uma função com a propriedade de ser contínua em todo seu domínio, mas em
nenhum ponto diferenciável. As plotagens dessas funções eram difíceis, pois elas são
recursivas, então o trabalho manual era praticamente impossível. Com o advento do
computador o professor Benoît Mandelbrot foi o primeiro a utilizar a máquina para plotar a
função recursiva estudada por Pierre Fatou, hoje chamada de Conjunto de Mandelbrot ou
simplesmente Fractal de Mandelbrot.

O conjunto de Mandelbrot é definido como o conjunto específico de pontos do plano complexo de Argand-Gauss que obedecem a distância máxima de 2 da origem do plano,
isto é, \textquotedblleft não tendem ao infinito\textquotedblright  para a sequência definida pela recorrência do número complexo  $Z = x+yi$.
 $Z_{0} = 0$

 $Z_{n+1} = Z_{N}^2 + C$

Onde $Z0$ e $Z_{n+1}$ são iterações n e n+1 do número complexo Z, e $C = a + bi$ fornece a posição de um ponto do plano complexo.
Já a parte real e imaginária do complexo Z pode ser desenvolvida até encontrarmos $_{n+1} = x_{n}^2 - y_{n}^2 + a$ e $y_{n+1} = 2x_{n}y_{n} + b$.
Para calcular os pontos de fractal pode-se utilizar o seguinte algoritmo:\\ \\ \\
\begin{algorithm}[H]
   \SetAlgoLined
   int Mandelbrot(Complexo c)
   
   int i = 0, ITR = 255;
   
   float x = 0, y = 0 tmp = 0;
   
   enquanto($x^2+y^2 <= 2^2$ \&\& $i < ITR$)
   
    $tmp = x^2 - y^2 + c.real$;\\
    $y = 2*x*y + c.img$; \\
    $i$++;
    
    se($i < ITR$) \Retorna{$i$};
    senão \Retorna{0};
   \label{alg1}
   \caption{\textsc{Algoritmo de Mandelbrot}}
 \end{algorithm}

 
 
 A geração da imagem de um fractal dependerá da quantidade de pontos no domínio,
neste caso distância máxima de 2 da origem, e o número máximo de iterações para
determinar se o ponto pertence ou não ao conjunto. Para se obter resoluções aceitáveis, isto
é, imagens onde é possível observar o padrão de similaridade multi-escala, imagens com
resolução maiores que 1200x1200 devem ser utilizadas. Desta forma temos um problema
que exige uma grande quantidade de operações em função da resolução do fractal que se
deseja obter. A figura \ref{fig:exampleFig1} mostra um exemplo de fractal.

\begin{figure}
  \centering
  \includegraphics{Fractal1.png}
  \caption{Fractal}
  \label{fig:exampleFig1} 
\end{figure}



Tendo isto em vista, utilizamos de programação paralela para tentar reduzir o problema fazendo com que ele seja feito de forma concorrente.
\\ \\ \\ \\ \\ \\ \\ \\ \\ \\











\section{Conceitos}\label{sec:Conc}
Nesta sessão será então abordado os principais conceitos utilizados ao longo deste artigo, com um objetivo principal de informar o leitor.
Ao decorrer desta sessão espera-se o entendimento básico de tais conceitos para então na próxima sessão começar a especificar o trabalho em si.

Esta sessão está divida em 4 (quatro) subsessões, são estas: Programação Sequencial, Programação Concorrente, C++11 e OpenMP.
Seguimos então para a subsessão 1.
\subsection{Programação Sequencial}
Programação Sequencial (\textit{Top Down}) é aquiela que é executada sequencialmente, da primeira a última linha de código,
seguindo rigorosamente a ordem em que o programa foi escrito \cite{Cormen}.A figura \ref{fig:exampleFig2} ilustra este processo, onde um determinado problema é executado
sequencialmente, possuindo assim uma série de instruções que devem ser executadas em um único processador.

\begin{figure}
 \centering
 \includegraphics{sequencial.png}
 \caption{Programação Sequencial}
 \label{fig:exampleFig2}
\end{figure}


\subsection{Programação Paralela}
Um programa é considerado paralelo quando este é visto como um conjunto de partes que podem ser resolvidas concorrentemente \cite{Cormen}.
Cada parte é igualmente constituída por uma série de instruções sequenciais, mas que no seu conjunto podem ser executadas simultaneamente em vários processadores,
conforme ilustra a Figura \ref{fig:exampleFig3}.

\begin{figure}
 \centering
 \includegraphics{paralelo.png}
 \caption{Programação Paralela}
 \label{fig:exampleFig3}
\end{figure}

\subsection{C++11}
C++11, formalmente conhecido por C++0x, é uma versão da linguagem de programação padrão C++.
Foi aprovado pela ISO em 2011, substituindo C++03 e suplantado pelo C++14 em 2014. O nome segue a tradição de nomear de acordo com o ano de publicação
da especificação da linguagem.
Essa versão inclue várias mudanças ao núcleo da linguagem e extende a biblioteca padrão do C++.
Algumas das principais mudanças são:
\begin{itemize}

 \item Manter a estabilidade e compatibilidade com C++98 e possivelmente com C.
 \item Melhorar C++ para facilitar Desenvolvimento de sistemas e bibliotecas, em vez de introduzir novas características úteis apenas para aplicações específicas.
 \item Fornecer soluções adequadas para os problemas do mundo real.
 \item Aumenta o desempenho e a capacidade de trabalhar diretamente com hardware.
 \item Entre outras.
\end{itemize}

\subsection{openmp}
OpenMP é uma interface de programação (API), portável, baseada na modelo de programação paralela de memória compartilhada para arquiteturas de múltiplos 
processadores. \cite{OpenMP:2014} Basicamente é composto por três componentes básicos: diretivas de compilação, biblioteca de execução e variáveis de ambiente. 
Sua principal facilidade é a existência de um único espaço de endereçamento através de todo o sistema de memória, onde cada processador pode ler e escrever 
em uma ou todas posições de memória. \cite{OpenMP:2013} O OpenMP está disponível para uso com os compiladores C/C++ e Fortran, podendo ser executado em ambientes Unix e Windows 
(Sistemas Multithreads) e foi definido (e é mantido), por um grupo composto na maioria por empresas de hardware e software, denominado como 
OpenMP ARb (Architecture Review Board), que possui diversas empresas, dentre elas: Intel, Copmaq, Sun Microsystems, dentre outras.
\section{Metodologia}\label{sec:Methodology}
Conforme especificado na sessão \ref{sec:Intro}, este trabalho foi realizado utilizando o algoritmo de Mandelbrot para problemas de Fractais, o qual foi
desenvolvido nas ferramentas C++11, OpenMP e com programação sequencial.
Salvo a programação sequencial, ambas as outras ferramentas utilizaram de um número de \textit{threads} entre um e oito, executados dez (10) vezes com cada número de \textit{threads}.
Ou seja, para um teste com uma (1) thread, foram realizados dez (10) testes, e assim sucessivamente até os dez testes com oito \textit{threads}.
A máquina utilizada para realizar todos os testes, foi a seguinte:
CPU:Amd Phenon X6 1055T 2.8Ghz, 6 Pocessadores, 6M cache L3, 512K cache L2, 64K cache L1, mem Ram: 8G DDR3 1066.
Foi calculado o \textit{Speed Up} através da seguinte formula:

$Speedup = \frac{X}{Y}$

Onde X é o tempo sequencial, e Y é o tempo paralelo, para definir o tempo médio de execução.
Assim então seguimos para a sessão \ref{sec:Results}.
\section{Resultados}\label{sec:Results}
Após a realização dos testes, foi então gerado os gráficos, como mostra a Figura \ref{fig:exampleFig4}, Figura \ref{fig:exampleFig5}, Figura \ref{fig:exampleFig6},  Figura \ref{fig:exampleFig7}
onde podemos ver a Eficiência medida pela divisão do \textit{SpeedUp} pelo número de \textit{threads} utilizado, e o número de \textit{threads} no eixo X.

\begin{figure}
 \centering
 \includegraphics{eficiencia1.PNG}
 \caption{Eficienca 800x600}
 \label{fig:exampleFig4}
\end{figure}




\begin{figure}
 \centering
 \includegraphics{eficiencia2.PNG}
 \caption{Eficienca para imagens HD}
 \label{fig:exampleFig5}
\end{figure}




\begin{figure}
  \centering
  \includegraphics{escalabilidade1.PNG}
 \caption{Escalabilidade 800x600}
 \label{fig:exampleFig6}
\end{figure}

\begin{figure}
 \centering
 \includegraphics{escalabilidade2.PNG}
 \caption{Eficienca para imagens HD}
 \label{fig:exampleFig7}
\end{figure}

Apesar do grafico de \textit{SpeedUp} nos dizer que estamos ganhando desempenho, e estamos realmente, não é a melhor métrica pois através do 
Gráfico de Eficiência podemos ver que estamos subaproveitando recursos, ou seja temos mais capacidade de paralelismo do que estamos utilizando. 

Isso é normal, pois vários fatores que influenciam no desempenhos como: Cache, Barramento, Memória e até mesmo número de \textit{threads}, pois a partir de certo ponto,
deve-se analisar os custos da criação de novas \textit{threads} e em nível mais critico, se o numero de \textit{threads} for muito grande, acabará por serializar a execução. 

\section{Conclusão}\label{sec:Conclusion}
Após então terminarmos os testes, concluímos que OpemMp por ter uma caracteristica de "Identificar" os setores paralelizaveis, conseguiu ter uma eficiência melhor que C++11 
que é necessário ao programador identificar os pontos de paralização e aplicar as técnicas nos locais exatos. Também os graficos estão escondendo uma ilusão de que 
quyanto mais \textit{threads} melhor, porque não usamos mais de oito \textit{threads}, mas o comportamento das curvas diz que se aumentássemos o número de \textit{threads} C++11 começaria a ganhar desempenho e OpemMp a perder, 
pode estar relacionando ao custo de estanciar um \textit{thread} em c++11 ser mais leve do que iniciar uma tarefa do OpemMp. 


\bibliographystyle{sbc}
\bibliography{sbc-template}

\end{document}
